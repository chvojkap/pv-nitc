%!TEX root=./main.tex
%\section{Constructions of Non-Malleable NITC using NIZK in ROM}
\subsection{Construction of Linearly Homomorphic Non-Malleable NITC}
\label{sec:linear-ROM}
We define language for our construction of a linearly homomorphic NITC depicted in \Cref{table:nitc-lh-rom} which relies on a one-time simulation sound NIZKs in the ROM in the following way:

\[
L = \left\{(h_1, h_2, c_0, c_1, c_2, c_3)| \exists (m,r):
\begin{aligned}
       (\land_{i=1}^3 c_i = h_i^{rN}(1+N)^m \bmod N^2) \land \\
       c_0 = g^r \bmod N\\
    \end{aligned}
    \right\}, 
\]
where $g, h_3, N$ are parameters specifying the language.


\begin{figure}[h!]
\begin{center}
\begin{tabular}{|ll|}
\hline
$\underline{\pgen(\seck, T)}$ 							   & $\underline{\com(\crs, m)}$ \\
$(p, q_, N, g) \leftarrow \genmod(\seck)$ & $r \rand \smplset$  \\
$\varphi(N):= (p-1)(q-1)$   & $c_0:= g^r \bmod N$ \\
$k_1, k_2 \rand \smplset$ & For $i \in [3]: c_i:= h_i^{rN}(1+N)^m \bmod N^2$\\
$t:= 2^T \bmod \varphi(N)/2$ & $\Phi := (h_1, h_2, c_0, c_1, c_2, c_3), w := (m, r)$ \\
For $i \in [2]: h_i:= g^{k_i} \bmod N$ &  $\pi_\com \leftarrow \nizk.\prove(\Phi, w)$\\
$h_3:=g^{t} \bmod N$ &  $c := (c_0, c_1, c_2, c_3)$\\
return $\crs:= (N,T,g,h_1,h_2, h_3)$ &  $\pi_\dec: = r$ \\
%$\crs \leftarrow \nizk.\setup(\seck)$ & \\
 & return $(c, \pi_\com, \pi_\dec)$\\
%return $\crs$     & \\
                                             &\\
$\underline{\cvrfy(\crs, c, \pi_\com)}$     & $\underline{\dvrfy(\crs,c, m, \pi_\dec)}$ \\
Parse $c$ as $(c_0, c_1, c_2, c_3)$  & Parse $c$ as $(c_0, c_1, c_2, c_3)$ \\
return $\nizk.\vrfy((h_1, h_2, c_0, c_1, c_2, c_3), \pi)$  & if $ \land_{i=1}^3 c_i = h_i^{\pi_\dec N}(1+N)^m  \bmod N^2$ \\
 & $\land c_0 = g^{\pi_\dec} \bmod N$\\
 & \tab return 1 \\
& return 0 \\
                                             &\\
$\underline{\fdecom(\crs,c)}$ & $\underline{\fdvrfy(\crs,c, m, \pi_\fdecom)}$ \\
Parse $c$ as $(c_0, c_1, c_2, c_3)$ & Parse $c$ as $(c_0, c_1, c_2, c_3)$\\
Compute $ \pi_\fdecom:=c_0^{2^T} \bmod N$ & if $c_3 = \pi_\fdecom^N (1+N)^m \bmod N^2$\\
$m:=\frac{c_3 \cdot \pi_\fdecom^{-N} (\bmod N^2) -1}{N}$ &  \tab return 1\\
return $(m,\pi_\fdecom)$ & return 0\\


                                             &\\
$\underline{\eval(\crs,\oplus_N, c_1, \dots, c_n)}$ &  \\
Parse $c_i$ as $(c_{i,0}, c_{i,1}, c_{i,2}, c_{i,3})$ & \\
\multicolumn{2}{|l|}{Compute $c_0 := \prod_{i=1}^n c_{i,0} \bmod N, c_1:= \bot, c_2:=\bot, c_3 := \prod_{i=1}^n c_{i,3} \bmod N^2$} \\
return $c := (c_0, c_1, c_2, c_3, \pi)$ & \\
%$\underline{\decom(\crs, \sk, c)}$     & $\underline{\fdecom(\crs,c)}$ \\
%Parse $c$ as $(c_0, c_1, c_2, \pi)$  & Parse $c$ as $(c_0, c_1, c_2, \pi)$ \\
%if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$  & if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$\\
%\tab Compute $y_1:= c_0^{k} \bmod N$  &   \tab Compute $ y_2:=c_0^{2^T} \bmod N$ \\
%\tab return $c_1 \cdot y_1^{-1} \bmod N$ & \tab return $c_2 \cdot y_2^{-1} \bmod N$ \\
%return $\bot$ & return $\bot$\\
\hline          
\end{tabular}
\caption{Construction of Linearly Homomorphic NITC in ROM. \\ $\oplus_N$ refers to addition $\bmod N$}
\label{table:nitc-lh-rom}
\end{center}
\end{figure}

%\begin{figure}[h!]
%\begin{center}
%\begin{tabular}{|ll|}
%\hline
%$\underline{\pgen(\seck, T)}$ 							   & $\underline{\com(\pk, m)}$ \\
%$(p, q_, N) \leftarrow \genmod(\seck)$ & $r \rand \smplset$  \\
%$\varphi(N):= (p-1)(q-1)$   & Compute $c_0:= g^r \bmod N$ \\
%Sample random generator $g$ of $\Jn$ & For $i \in [3]: c_i:= h_i^{rN}(1+N)^m \bmod N^2$\\
%$k_1, k_2 \rand \smplset$ & $\Phi := (h_1c_0, c_1, c_2, c_3), w := (m, r)$ \\
%$t:= 2^T \bmod \varphi(N)/2$ &  $\pi \leftarrow \nizk.\prove(\Phi, w)$\\
%For $i \in [2]: h_i:= g^{k_i} \bmod N$ &  $c := (c_0, c_1, c_2, c_3, \pi)$\\
%$h_3:=g^{t} \bmod N$ &  $\pi_\com:= \bot, \pi_\dec: = r$ \\
%%$\crs \leftarrow \nizk.\setup(\seck)$ & \\
%return $\crs:= (N,T,g,h_1,h_2, h_3)$ & return $(c, \pi_\com, \pi_\dec)$\\
%%return $\crs$     & \\
%                                             &\\
%$\underline{\cvrfy(\crs, c, \pi_\com)}$     & $\underline{\dvrfy(\crs,c, m, \pi_\dec)}$ \\
%Parse $c$ as $(c_0, c_1, c_2, c_3 \pi)$  & Parse $c$ as $(c_0, c_1, c_2, c_3 \pi)$ \\
%return $\nizk.\vrfy((c_0, c_1, c_2, c_3,), \pi)$  & if $ \land_{i=1}^3 c_i = h_i^{rN}(1+N)^m  \bmod N^2 \land c_0 = g^r \bmod N$\\
% & \tab return 1 \\
%& return 0 \\
%                                             &\\
%$\underline{\fdecom(\crs,c)}$ & $\underline{\fdvrfy(\crs,c, m, \pi_\fdecom)}$ \\
%Parse $c$ as $(c_0, c_1, c_2, c_3, \pi)$ & Parse $c$ as $(c_0, c_1, c_2, c_3, \pi)$\\
%if $\nizk.\vrfy((c_0, c_1, c_2,c_3), \pi)= 1$& if $\nizk.\vrfy((c_0, c_1, c_2,c_3), \pi)= 1 \land $\\
%\tab Compute $ \pi_\fdecom:=c_0^{2^T} \bmod N$ &  $c_3 = \pi_\fdecom^N (1+N)^m \bmod N^2$\\
%\tab Compute $m:=\frac{c_3 \cdot \pi_\fdecom^{-N} (\bmod N^2) -1}{N}$ &\tab return 1\\
%\tab return $(m,\pi_\fdecom)$ & return 0\\
%return $\bot$ & \\
%
%%$\underline{\decom(\crs, \sk, c)}$     & $\underline{\fdecom(\crs,c)}$ \\
%%Parse $c$ as $(c_0, c_1, c_2, \pi)$  & Parse $c$ as $(c_0, c_1, c_2, \pi)$ \\
%%if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$  & if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$\\
%%\tab Compute $y_1:= c_0^{k} \bmod N$  &   \tab Compute $ y_2:=c_0^{2^T} \bmod N$ \\
%%\tab return $c_1 \cdot y_1^{-1} \bmod N$ & \tab return $c_2 \cdot y_2^{-1} \bmod N$ \\
%%return $\bot$ & return $\bot$\\
%
%\hline          
%\end{tabular}
%\caption{NY Construction of NITC}
%\label{table:nitc}
%\end{center}
%\end{figure}

% \todo{appendix?}
\begin{proof}
Completeness is implied by the completeness of the NIZK and can be verified by inspection. 

%Our construction is based on the Naor-Yung paradigm where we combine three Paillier-type ciphertext with shared randomness.  


%Similarly to \cite{SCN:BiaMasVen16} we define a PPT algorithm $\rerand$ in Figure~\ref{fig:rerand}, which takes two ciphertexts generated with independent randomness, both public keys, only one secret key (in our case $k$) and randomness which was used to encrypt a message using the public key $g, h_1$. 
%%We assume that modulus $N$ is implicitly known.\todo{Why not explicit?} 
%% which corresponds to the secret key which is given as the input. 
%
%\begin{figure}[tb]
%\centering
%\begin{minipage}{0.75\textwidth}
%$\underline{\rerand(c:= (g^{r}, h_1^{r}\cdot m), c':= (g^{r'}, h_2^{r'}\cdot m), N, h_1, h_2, k, r)}:$
%\vspace{-2mm}
%\begin{itemize}
%\item $c_0:= g^{r}\cdot{g^{r'}} = g^{r+r'} \bmod N$;
%\item $c_1:= (g^{r'})^k \cdot h_1^{r}\cdot m  =  h_1^{r'}\cdot h_1^{r}\cdot m = h_1^{r+r'}\cdot m \bmod N$;
%\item $c_2:=h_2^{r} \cdot h_2^{r'}\cdot m = h_2^{r+r'}\cdot m \bmod N$.
%\end{itemize}
%\end{minipage}
%\caption{\label{fig:rerand}Algorithm $\rerand$.}
%\end{figure}
%
%
%
%
%It is straightforward to see that the ciphertext returned by $\rerand$ is perfectly distributed to the ciphertext produced using a shared randomness where the pair $(c_0, c_1)$ encrypts a message $m$ and the pair $(c_0, c_2)$ encrypts message $m'$.


% We note that if we use value $2^T$ as a secret key, then in order to compute $c_2$ we have to execute $T$ repeated squarings, but since $T$ is polynomial in $\secpar$ this computations is considered to be efficient.

\newsequenceofgames{NITC-LH-ROM}
To prove security we define a sequence of games $\games_0 - \games_{13}$.  For $i \in \{0,1,\dots,13\}$ we denote by $\games_i = 1$ the event that the adversary $\adv = \{(\adv_{1,\secpar}, \adv_{2, \secpar})\}_{\secpar \in \nats}$ outputs $b'$ in the game $\games_i$ such that $b = b'$.
%In individual games we use the algorithm $\decom$ define in \Cref{fig:deco-rom-lh} to answer decommitment queries efficiently. 
\begin{figure}[h!]
\begin{center}
\begin{tabular}{|l|}
\hline
$\underline{\decom(\crs, c, \pi_\com, i)}$\\
Parse $c$ as $(c_0, c_1, c_2, c_3)$\\
if $\nizk.\vrfy((h_1, h_2, c_0, c_1, c_2, c_3), \pi_\com)= 1$\\
\tab Compute $y:= c_0^{k_i} \bmod N$\\
\tab return $\frac{c_i \cdot y^{-N} (\bmod N^2) -1}{N}$\\
return $\bot$\\
\hline          
\end{tabular}
\caption{Decommitment oracle}
\label{fig:deco-rom-lh}
\end{center}
\end{figure}

\nextgame{G0}
Game $\games_\thisgame$ corresponds to the original security experiment where decommitment queries are answered using $\fdecom$.

\nextgame{DecOracle}
In game $\games_\thisgame$ decommitment queries are answered using the algorithm $\decom$ defined in \Cref{fig:deco-rom-lh} with $i:=1$, meaning that secret key $k_1$ and ciphertext $c_1$ are used, to answer decommitment queries efficiently. 


\begin{lemma}\label{nitc-rom-lh:flem}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \snd^\nizk_\advB.
\]
\end{lemma}

Notice that if $c_1$ and $c_3$ contain the same message, both oracles answer decommitment queries consistently. Let $\event$ denote the event that the adversary $\adv$ asks a decommitment query $(c, \pi_\com)$ such that its decommitment using the key $k_1$ is different from its decommitment using $\fdecom$. Since $\games_\prevgame$ and $\games_\thisgame$ are identical until $\event$ happens, we bound the probability of $\event$. Concretely, we have

\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \Pr[\event]. 
\]

We construct an adversary $\advB$ that breaks soundness with respect to auxiliary input $\aux:=(p,q)$ of the NIZK. 
The adversary $\advB_{\secpar}(p,q)$ proceeds as follows:
\vspace{-2mm}
\begin{enumerate}
\item Samples $k_1, k_2\rand \smplset$, computes $h_1 := g^{k_1} \bmod N, h_2:=g^{k_2} \bmod N, \varphi(N):=(p-1)(q-1), t:=2^{T} \bmod \ord$ and sets $\crs:=(N, T, g, h_1, h_2, h_3)$ where $h_3$ is given by $L$. 
\item Then it runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
\item It samples $b \rand \bits, r \rand \smplset$ and computes $c_0^*:=g^r, c_1^*:=h_1^{rN}(1+N)^{m_b}, c_2^*:=h_2^{rN}(1+N)^{m_b}, c_3^*:=h_3^{rN}(1+N)^{m_b}$. It sets $(s:=\mathlist(h_1, h_2, c_0^*, c_1^*, c_2^*, c_3^*), w:=(m,r))$ and runs $\pi^* \leftarrow \nizk.\prove(s,w)$.
\item Next, it runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*, c_3^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
\item Finally, it checks whether there exists a decommitment query $(c, \pi_\com)$ such that $\deco(c, \pi_\com, 1) \neq \dec(\crs,c, \pi_\com, 1)$. If $\event$ occurs, then this is the case, and it returns $((h_1, h_2, c_0, c_1, c_2, c_3), \pi_\com)$. Notice that finding such a query can be done efficiently with the knowledge of $t$ since instead of running $\fdecom$ it is possible to verify the proof and simply compute $\frac{c_3\cdot (c_0^t)^{-N}(\bmod N^2)-1}{N}$ which produce the same result as $\fdecom$.
\end{enumerate}

$\advB$ simulates $\games_\thisgame$ perfectly and if the event $\event$ happens, then it outputs a valid proof for a statement which is not in the specified language $L$. Therefore we get
\[\Pr[\event] \leq \snd^\nizk_\advB.\]

%Let $\gnr$ denote the event that the sampled $g$ in $\kgen$ is a generator of $\qrn$. Recall that $N = pq$ where $p = 2p'+1$ and $q = 2q'+1$. Because $g$ is sampled uniformly at random and $\qrn$ has $\varphi(|\qrn|) = (p'-1)(q'-1)$ generators, this event happens with overwhelming probability. Concretely, $\Pr[\gnr] = 1-\frac{1}{p'}-\frac{1}{q'}+\frac{1}{p'q'}$.
%Therefore the following holds.
%\begin{lemma}\label{tpke3:flem} 
%\begin{align*}
%\Pr[\games_\thisgame = 1] &= \Pr[\games_\thisgame = 1| \gnr]\Pr[\gnr] + \Pr[\games_\thisgame = 1| \overline{\gnr}]\Pr[\overline{\gnr}] \\
%&\leq \Pr[\games_\thisgame = 1| \gnr]\Pr[\gnr] + \Pr[\overline{\gnr}] \\
%&= \Pr[\games_\thisgame = 1| \gnr]\left( 1-\frac{1}{p'}-\frac{1}{q'}+\frac{1}{p'q'} \right) + \frac{1}{p'}+\frac{1}{q'}-\frac{1}{p'q'}.
%\end{align*}
%\end{lemma}




\nextgame{SimulProof}
Game $\games_\thisgame$ proceeds exactly as the previous game but we use the zero-knowledge simulator $(\pi^*, \st) \leftarrow \simul(1, \st, (h_1, h_2, c_0^*,c_1^*,c_2^*,c_3^*))$ to produce a simulated proof for the challenge commitment and $\simul(2, \st, \cdot)$ to answer random oracle queries. By zero-knowledge security of underlying NIZK we directly obtain
\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \zk^\nizk_\advB.
\]
\end{lemma}

We construct an adversary $\advB = \{\advB_\secpar\}_{\secpar \in \N}$ against zero-knowledge security of NIZK as follows:
\vspace{-2mm}
\begin{enumerate}
\item Samples $k_1, k_2 \rand \smplset$, computes $h_1 := g^{k_1} \bmod N, h_2 := g^{k_2} \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2, h_3)$. 
\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
\item Samples $b \rand \bits, r \rand \smplset$ and computes $c_0^*:=g^r, c_1^*:=h_1^{rN}(1+N)^{m_b}, c_2^*:=h_2^{rN}(1+N)^{m_b}, c_3^*:=h_3^{rN}(1+N)^{m_b}$. It submits $(s:=\mathlist(h_1,h_2,c_0^*, c_1^*, c_2^*, c_3^*), w:=(m,r))$ to its oracle and obtains proof $\pi^*$ as answer.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*, c_3^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
\item Returns the truth value of $b=b'$.
\end{enumerate}
If the proof $\pi^*$ is generated using $\nizk.\prove$, then $\advB$ simulates $\games_\prevgame$ perfectly. Otherwise $\pi^*$ is generated using $\simul_1$ and $\advB$ simulates $\games_\thisgame$ perfectly. This proofs the lemma.


\nextgame{RndExp}
In $\games_\thisgame$ we sample $r$ uniformly at random from $[\varphi(N)/2]$. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \frac{1}{p}+\frac{1}{q}-\frac{1}{N}.
\]
\end{lemma}
%At first we remark that for upper bounding the difference between the games we use a statistical argument. Because $r$ appears only in the exponent of the group generator, we later sample a random element from the group $\qrn$ which can be done efficiently. 
Since the only difference between the two games is in the set from which we sample $r$, to upper bound the advantage of adversary we can use \Cref{sampling-lemma} with $\ell:=2$, which directly yields required upper bound.

%\nextgame{ReRand}
%In Game $\games_\thisgame$ we produce the challenge commitment by encrypting the challenge message using two independent random exponents $r \rand \smplset, r' \rand [\varphi(N)/4]$ to obtain $c:= (g^{r}, h_1^{r}\cdot m_b), c':= (g^{r'}, h_2^{r'}\cdot m_b)$ and then run $\rerand(c,c',N, \allowbreak h_1, h_2,k,r)$ to obtain resulting ciphertext $(c_0^*, c_1^*, c_2^*)$. Since $r'$ is sampled uniformly at random from $[\varphi(N)/4]$ the ciphertext distributions in both games  are the same. Therefore 
%
%\begin{lemma}
%\[
%\Pr[\games_\prevgame = 1] = \Pr[\games_\thisgame = 1].
%\]
%\end{lemma}


\nextgame{SSSA}
In $\games_\thisgame$ we sample $y_3 \rand \Jn$ and compute $c_3^*$ as $y_3^N (1+N)^{m_b}$.

Let $\tilT_\sss(\secpar)$ be the polynomial whose existence is guaranteed by the SSS assumption.
Let $\poly_\advB(\secpar)$ be the fixed polynomial which bounds the time required to execute Steps 1--2 and answer decommitment queries in Step 3 of the adversary $\advB_{2, \secpar}$ defined below. Set $\undT := (\poly_\advB(\secpar))^{1 / \ugap}$.  Set $\tilT_\nitc := \max(\tilT_\sss, \undT)$.
\begin{lemma}
From any polynomial-size adversary $\adv = \{(\adv_{1,\secpar}, \adv_{2, \secpar})\}_{\secpar \in \nats}$, where depth of $\adv_{2, \secpar}$ is at most $T^{\ugap}(\secpar)$ for some $T(\cdot) \geq \undT(\cdot)$ we can construct a polynomial-size adversary $\advB = \{(\advB_{1,\secpar}, \advB_{2, \secpar})\}_{\secpar \in \nats}$ where the depth of $\advB_{2, \secpar}$ is at most $T^{\gap}(\secpar)$ with
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \advtg_\advB^\sss.
\]
\end{lemma}

The adversary $\advB_{1,\secpar}(N, T(\secpar), g):$
\vspace{-2mm}
\begin{enumerate}
\item Samples $k_1, k_2 \rand \smplset$, computes $h_1 := g^{k_1} \bmod N, h_2 := g^{k_2} \bmod N,  h_3 := g^{2^{T(\secpar)}} \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2, h_3)$. Notice that value $h_3$ is computed by repeated squaring.
\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
\item Outputs $(N,g,k_1, k_2, h_1,h_2,h_3, m_0, m_1, \st)$
\end{enumerate}

The adversary $\advB_{2,\secpar}(x,y,(N,g,k_1, k_2, h_1,h_2,h_3, m_0, m_1, \st)):$
\vspace{-2mm}
\begin{enumerate}
\item Samples $b \rand \bits$, computes $c_0^*:=x, c_1^*:=x^{k_1N}(1+N)^{m_b}, c_2^*:=x^{k_2N}(1+N)^{m_b}, c_3^*:=y^{N}(1+N)^{m_b}$.
\item Runs $\pi^* \leftarrow \simul(1, \st', (h_1, h_2, c_0^*, c_1^*, c_2^*, c_3^*))$.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*, c_3^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
\item Returns the truth value of $b=b'$.
\end{enumerate}
Since $g$ is a generator of $\Jn$ and $x$ is sampled uniformly at random from $\Jn$ there exists some $r \in [\varphi(N)/2]$ such that $x = g^{r}$. Therefore when $y = x^{2^T} = (g^{2^T})^{r} \bmod N$, then $\advB$ simulates $\games_\prevgame$ perfectly. Otherwise $y$ is random value and $\advB$ simulates $\games_\thisgame$ perfectly. 

Now we analyse the running time of the constructed adversary. Adversary $\advB_1$ computes $h_3$ by $T(\secpar)$ consecutive squarings and because $T(\secpar)$ is polynomial in $\secpar$, $\advB_1$ is efficient. Moreover, $\advB_2$ fulfils the depth constraint:
\[ \dep(\advB_{2,\secpar}) = \poly_\advB(\secpar) + \dep(\adv_{2,\secpar}) \leq \undT^{\ugap}(\secpar) + T^{\ugap}(\secpar) \leq 2 T^{\ugap}(\secpar) = o(T^{\gap}(\secpar)). \] 

Also $T(\cdot) \geq \tilT_\nitc(\cdot) \geq \tilT_\sss(\cdot)$ as required.

%\nextgame{RndExp2}
%In $\games_\thisgame$ we stop to use $\rerand$ algorithm. Concretely, we sample $r \rand [\varphi(N)/4], y_2 \rand \qrn$ and compute challenge ciphertext as $c^*:=(g^r, h_1^r \cdot m_b, y_2 \cdot m_b)$. The ciphertext has the same distribution as in the previous game. Therefore 
%
%\begin{lemma}
%\[
%\Pr[\games_\prevgame = 1] = \Pr[\games_\thisgame = 1].
%\]
%\end{lemma}
%\nextgame{RndExp3}




\nextgame{DCR1}
In $\games_\thisgame$ we sample $y_3 \rand \Zns$ such that it has Jacobi symbol 1 and compute $c_3^*$ as $y_3(1+N)^{m_b}$. 

\begin{lemma}\label{lem:dcr-rom-lh}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \advtg_\advB^\dcr.
\]
\end{lemma}
We construct an adversary $\advB = \{\advB_\secpar\}_{\secpar \in \N}$ against DCR.

$\advB_{\secpar}(N,y):$
\vspace{-2mm}
\begin{enumerate}
\item Samples $g, y_3, x \rand \Jn, k_1, k_2 \rand \smplset$, computes $h_1 := g^{k_1} \bmod N, h_2 := g^{k_2} \bmod N,  h_3 := g^{2^{T}} \bmod N$ and sets $\crs:=(N, T, g, h_1, h_2, h_3)$. Notice that value $h_3$ is computed by repeated squaring.
\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
\item Samples $b \rand \bits, w \rand \Zns$ such that $\left( \frac{y}{N} \right)= \left( \frac{w}{N} \right)$. We remark that computing Jacobi symbol can be done efficiently without knowing factorization of N.
\item Computes $c_0^*:=x, , c_1^*:=x^{k_1N}(1+N)^{m_b}, c_2^*:=x^{k_2N}(1+N)^{m_b}, c_3^*:=yw^{N}(1+N)^{m_b}$. Runs $\pi^* \leftarrow \simul(1, \st', (h_1, h_2, c_0^*, c_1^*, c_2^*, c_3^*))$.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*, c_3^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
\item Returns the truth value of $b=b'$.
\end{enumerate}
%If $y = v^N \bmod N^2$ then $yw^N = v^N w^N = (vw)^N$ and hence $yw^N$ is $N$-th residue. Moreover, the Jacobi symbol of $yw$ is 1, since the Jacobi symbol is multiplicatively homomorphic. Therefore $\advB$ simulates $\games_\prevgame$ perfectly. Otherwise $y$ is uniform random element in $\Zns$ then $yw^N$ is also uniform in $\Zns$ and $\advB$ simulates $\games_\thisgame$ perfectly. This proofs the lemma. We remark that at this point $c_3^*$ does not reveal any information about $m_b$.

If $y = v^N \bmod N^2$ then $yw^N = v^N w^N = (vw)^N$ and hence $yw^N$ is $N$-th residue. Moreover, the Jacobi symbol of $yw$ is 1, since the Jacobi symbol is multiplicatively homomorphic. Therefore $\advB$ simulates $\games_\prevgame$ perfectly. 

Otherwise, if $y$ is uniform random element in $\Zns$, then $yw^N$ is also uniform among all elements of $\Zns$ that have Jacobi symbol 1 and $\advB$ simulates $\games_\thisgame$ perfectly. This proves the lemma.

We remark that at this point $c_3^*$ does not reveal any information about $b$. Here we use that if $x = y \bmod N$ then $\left( \frac{x}{N} \right)= \left( \frac{y}{N} \right)$ and that there is an isomorphism $f:\Zn^* \times \Zn \rightarrow\Zns$ given by $f(u,v)=u^N(1+N)^v = u^N(1+vN) \bmod N^2$ (see e.g. \cite[Proposition 13.6]{books/crc/KatzLindell2014}).  Since $f(u,v) \bmod N = u^N + u^NvN \bmod N = u^N \bmod N$, that means that Jacobi symbol $\left( \frac{f(u,v)}{N} \right)$ depends only on $u$. Hence if $\left( \frac{f(u,v)}{N} \right) = 1$ then it must hold that $\left( \frac{f(u,r)}{N} \right) = 1$ for all $r \in \Zn$. This implies that a random element $f(u,v)$ in $\Zns$ with $\left( \frac{f(u,v)}{N} \right) = 1$ has a uniformly random distribution of $v$ in $\Zn$. Therefore if $yw^N = u^N(1+N)^v \bmod N^2$ then  $yw^N(1+N)^{m_b}  = u^N(1+N)^{m_b+v} \bmod N^2$. Since $v$ is uniform in $\Zn$, $(m_b + v)$ is also uniform in $\Zn$, which means that ciphertext $c_3^*$ does not reveal any information about $b$. 

\nextgame{RndExp2}
In $\games_\thisgame$ we sample $k_2$ uniformly at random from $[\varphi(N)/2]$. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \frac{1}{p}+\frac{1}{q}-\frac{1}{N}.
\]
\end{lemma}

Again using a statistical argument this lemma directly follows from \Cref{sampling-lemma} with $\ell:=2$.

\nextgame{DDH}
In $\games_\thisgame$ we sample $y_2 \rand \Jn$ and compute $c_2^*$ as  $y_2^N(1+N)^{m_b}$. 

\begin{lemma}\label{lem:ddh-rom-lh}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \advtg_\advB^\ddh.
\]
\end{lemma}
We construct an adversary $\advB = \{\advB_\secpar\}_{\secpar \in \N}$ against DDH in the group $\Jn$. %Given \Cref{thm:ddh} this implies an adversary against DDH in large prime-order subgroups of $\Zn^*$.

$\advB_{\secpar}(N,g,g^\alpha, g^\beta, g^\gamma):$
\vspace{-2mm}
\begin{enumerate}
\item Samples $k_1 \rand \smplset$, computes $h_1 := g^{k_1} \bmod N,  h_3 := g^{2^{T}} \bmod N$ and sets $\crs:=(N, T, g, h_1, h_2:=g^\alpha, h_3)$.
\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
\item Samples $b \rand \bits, y_3 \rand \Zns$ such that it has Jacobi symbol 1 and computes $(c_0^*, c_1^*, c_2^*, c_3^*):=(g^\beta, (g^\beta)^{k_1 N}(1+N)^{m_b}, (g^{\gamma})^N(1+N)^{m_b}, y_3(1+N)^{m_b}).$ Runs $\pi^* \leftarrow \simul(1, \st', (h_1, h_2, c_0^*, c_1^*, c_2^*, c_3^*))$.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*,c_3^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
\item Returns the truth value of $b=b'$.
\end{enumerate}
If $\gamma = \alpha\beta$, then $\advB$ simulates $\games_\prevgame$ perfectly. Otherwise $g^\gamma$ is uniform random element in $\Jn$ and $\advB$ simulates $\games_\thisgame$ perfectly. This proofs the lemma.

\nextgame{RndExp3}
In $\games_\thisgame$ we sample $k_2$ uniformly at random from $\smplset$. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \frac{1}{p}+\frac{1}{q}-\frac{1}{N}.
\]
\end{lemma}

This lemma directly follows from \Cref{sampling-lemma}.

\nextgame{DCR2}
In $\games_\thisgame$ we sample $y_2 \rand \Zns$ such that it has Jacobi symbol 1 and compute $c_2^*$ as $y_2(1+N)^{m_b}$. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \advtg_\advB^\dcr.
\]
\end{lemma}
This can be proven in similar way as \Cref{lem:dcr-rom-lh}. We remark that at this point $c_2^*$ does not reveal any information about $m_b$.



\nextgame{SimSnd}

In $\games_\thisgame$ we answer decommitment queries using $\dec$ (\Cref{fig:deco-rom-lh}) with $i:=2$ which means that secret key $k_2$ and ciphertext $c_2$ are used. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \simsnd^\nizk_\advB. 
\]
\end{lemma}

Let $\event$ denote the event that adversary $\adv$ asks a decommitment query $(c, \pi_\com)$ such that its decommitment using the key $k_1$ is different from its decommitment using the key $k_2$. Since $\games_\prevgame$ and $\games_\thisgame$ are identical until $\event$ does not happen, by the standard argument it is sufficient to upper bound the probability of happening $\event$. Concretely,  

\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \Pr[\event]. 
\]

We construct an adversary $\advB$ which breaks one-time simulation soundness of the NIZK. 

The adversary $\advB_{\secpar}^{\simul_1, \simul_2}:$
\vspace{-2mm}
\begin{enumerate}
\item Computes $\crs \leftarrow \pgen(\seck, T)$ as defined in the construction where the value $h_3$ is computed using repeated squaring instead.
\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_2$.
\item Samples $b \rand \bits, x \rand \Jn, y_2, y_3 \rand \Zns$ and computes $(c_0^*, c_1^*, c_2^*, c_3^*):=(x, x^{k_1 N} (1+N)^{m_b}, y_2 (1+N)^{m_b}, y_3 (1+N)^{m_b})$. Forwards $(h_1, h_2, c_0^*, c_1^*, c_2^*, c_3^*)$ to simulation oracle $\simul_1$ and obtains a proof $\pi^*$.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*, c_3^*), \pi^*, \st)$ and answers decommitment queries using $k_2$.
\item Find a decommitment query $(c, \pi_\com)$ such that $\dec(\crs, c, \pi_\com, 1) \neq \allowbreak \dec(\crs,c, \pi_\com, 2)$ and returns $((h_1, h_2, c_0, c_1, c_2, c_3), \pi_\com)$.
\end{enumerate}

$\advB$ simulates $\games_\thisgame$ perfectly and if the event $\event$ happens, it outputs a valid proof for a statement which is not in the specified language $L$. Therefore
\[\Pr[\event] \leq \simsnd^\nizk_\advB,\]
which concludes the proof of the lemma.  

%\nextgame{ReRand2}
%In $\games_\thisgame$ we use the key $t$ and randomness $r'$ as input for rerandomization. Concretely we compute $\rerand(c,c',h_1,h_2,t,r')$. This is just conceptual change since the ciphertext distributions are the same in both games and therefore 
%
%\begin{lemma}
%\[
%\left|\Pr[\games_\prevgame = 1] = \Pr[\games_\thisgame = 1]\right|.
%\]
%\end{lemma}
%
%\nextgame{RndExp4}
%In $\games_\thisgame$ we sample $r$ uniformly at random from $\varphi(N)$. 
%
%\begin{lemma}
%\[
%\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \frac{1}{N}.
%\]
%\end{lemma}

\nextgame{RndExp4}
In $\games_\thisgame$ we sample $k_1$ uniformly at random from $[\varphi(N)/2]$. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \frac{1}{p}+\frac{1}{q}-\frac{1}{N}.
\]
\end{lemma}

This lemma directly follows from \Cref{sampling-lemma} with $\ell:=2$.

\nextgame{DDH2}
In $\games_\thisgame$ we sample $y_1 \rand \Jn$ and compute $c_1^*$ as  $y_1^{N} (1+N)^{m_b}$. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \advtg_\advB^\ddh.
\]
\end{lemma}
This can be proven in similar way as \Cref{lem:ddh-rom-lh}.

\nextgame{DCR3}
In $\games_\thisgame$ we sample $y_1 \rand \Zns$ such that it has Jacobi symbol 1 and compute $c_1^*$ as $y_1(1+N)^{m_b}$. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \advtg_\advB^\dcr.
\]
\end{lemma}
This can be proven in similar way as \Cref{lem:dcr-rom-lh}. We remark that at this point $c_1^*$ does not reveal any information about $m_b$.

\begin{lemma}\label{nitc-rom-lh:llem}
\[
\Pr[\games_\thisgame = 1] = \half.
\]
\end{lemma}

Clearly, $c_0^*$ is uniform random element in $\Jn$ and hence it does not contain any information about the challenge message. Since $y_1, y_2, y_3$ are sampled uniformly at random from $\Zns$ the ciphertexts $c_1^*, c_2^*, c_3^*$ are also uniform random elements in $\Zns$ and hence do not contain any information about the challenge message $m_b$. Therefore, an adversary can not do better than guessing.

By combining Lemmas \ref{nitc-rom-lh:flem} - \ref{nitc-rom-lh:llem} we obtain the following:
\begin{align*}
\advtg^{\nitc}_{\adv} &= \left| \Pr[\games_0 = 1] - \half \right| \leq \sum_{i=0}^{12} \left|\Pr[\games_i = 1] - \Pr[\games_{i+1} = 1] \right| + \left|\Pr[\games_{13}- \half\right| \\
 &\leq  \snd^\nizk_\advB + \zk^\nizk_\advB + \advtg^{\sss}_{\advB} + \simsnd^{\nizk}_{\advB} + 2 \advtg^{\ddh}_{\advB} + 3 \advtg^{\dcr}_{\advB} \\ &+ 4 \left( \frac{1}{p}+\frac{1}{q}-\frac{1}{N} \right).
\end{align*}
which concludes the proof.
\end{proof}
% \todo{appendix end}



\begin{theorem}
\label{thm:NITC-lin-ROM}
If $\nizk = (\nizk.\prove, \nizk.\vrfy)$ is a one-time simulation-sound non-interactive zero-knowledge proof system for $L$ which is sound with respect to auxiliary input $\aux:=(p,q)$, the strong sequential squaring assumption with gap $\gap$ holds relative to $\genmod$ in $\Jn$, the Decisional Composite Residuosity assumption holds relative to $\genmod$, and the Decisional Diffie-Hellman assumption holds relative to $\genmod$ in $\Jn$, then \mathlist{(\pgen, \com, \cvrfy, \dvrfy, \fdecom)} defined in \Cref{table:nitc-lh-rom} is an IND-CCA-secure non-interactive timed commitment scheme with $\ugap$, for any $\ugap < \gap$. 
\end{theorem}
The proof can be found in \Cref{app:NITC-lin-ROM}.

\begin{theorem}
$(\pgen, \com, \cvrfy, \dvrfy, \fdecom)$ defined in \Cref{table:nitc-lh-rom} is a BND-CCA-secure non-interactive timed commitment scheme. 
\end{theorem}
{}
\begin{proof}
This can be proven in the same way as \Cref{bnd-cca-lh}.
\end{proof}

\begin{theorem}
If $\nizk = (\nizk.\prove, \nizk.\vrfy)$ is a non-interactive zero-knowledge proof system for $L$, then \mathlist{(\pgen, \com, \cvrfy, \dvrfy, \fdecom, \fdvrfy)} defined in \Cref{table:nitc-lh-rom} is a publicly verifiable non-interactive timed commitment scheme.
\end{theorem}

\begin{proof}
This can be proven in the same way as \Cref{pv-lh}.
\end{proof}

It is straightforward to verify that considering $\eval$ algorithm, our construction yields linearly homomorphic NITC. 
\begin{theorem}\label{hom-lh-rom}
The NITC \mathlist{(\pgen, \com, \cvrfy, \dvrfy, \fdecom, \fdvrfy, \eval)} defined in \Cref{table:nitc-lh-rom} is a linearly homomorphic non-interactive timed commitment scheme.
\end{theorem}









\subsection{Construction of Multiplicatively Homomorphic Non-Malleable NITC}
\label{sec:mult-ROM}
We define language for our construction of a multiplicatively homomorphic NITC which relies on a Sigma protocol in the following way:
\[
L = \left\{(h_1, h_2, c_0, c_1, c_2)| \exists (m,r):
\begin{aligned}
       (\land_{i=1}^3 c_i = h_i^{r}m \bmod N) \land
       c_0 = g^r \bmod N\\
    \end{aligned}
    \right\}, 
\]
where $g, N$ are parameters specifying the language.

Our construction is given in \Cref{table:nitc-mh-rom} where $(\nizk.\prove, \nizk.\vrfy)$ is the Fiat-Shamir transform of a Sigma protocol for language $L$. Since it is not straightforward to provide a security proof directly with respect to standard definition of one-time simulation sound NIZK, we provide the security proof in the random oracle model relying on the properties of the underlying Sigma protocol.


\begin{figure}[h!]
\begin{center}
\begin{tabular}{|ll|}
\hline
$\underline{\pgen(\seck, T)}$ 							   & $\underline{\com(\crs, m)}$ \\
$(p, q_, N, g) \leftarrow \genmod(\seck)$ & $r \rand \smplset$  \\
$\varphi(N):= (p-1)(q-1)$   & $c_0:= g^r \bmod N$ \\
$k_1\rand \smplsetqrn$ & For $i \in [2]: c_i:= h_i^{r}m \bmod N$\\
$t:= 2^T \bmod \varphi(N)/4$ & $\Phi := (h_1, h_2, c_0, c_1, c_2), w := (m, r)$ \\
$h_1:= g^{k_1} \bmod N$ &  $\pi_\com \leftarrow \nizk.\prove(\Phi, w)$\\
$h_2:=g^{t} \bmod N$ &  $c := (c_0, c_1, c_2)$\\
return $\crs:= (N,T,g,h_1,h_2)$ &  $\pi_\dec: = r$ \\
%$\crs \leftarrow \nizk.\setup(\seck)$ & \\
 & return $(c, \pi_\com, \pi_\dec)$\\
%return $\crs$     & \\
                                             &\\
$\underline{\cvrfy(\crs, c, \pi_\com)}$     & $\underline{\dvrfy(\crs,c, m, \pi_\dec)}$ \\
Parse $c$ as $(c_0, c_1, c_2)$  & Parse $c$ as $(c_0, c_1, c_2)$ \\
return $\nizk.\vrfy((h_1, h_2, c_0, c_1, c_2), \pi_\com)$  & if $ \land_{i=1}^2 c_i = h_i^{\pi_\dec}m  \bmod N \land c_0 = g^{\pi_\dec} \bmod N$\\
 & \tab return 1 \\
& return 0 \\
                                             &\\
$\underline{\fdecom(\crs,c)}$ & $\underline{\eval(\crs,\otimes_N, c_1, \dots, c_n)}$ \\
Parse $c$ as $(c_0, c_1, c_2)$ & Parse $c_i$ as $(c_{i,0}, c_{i,1}, c_{i,2})$\\
 Compute $ y:=c_0^{2^T} \bmod N$  & Compute $c_0 := \prod_{i=1}^n c_{i,0} \bmod N,  c_1:= \bot$\\
$m:=c_2 \cdot y^{-1} \bmod N$  &   Compute $c_2 := \prod_{i=1}^n c_{i,2} \bmod N $\\
return $m$  & return $c := (c_0, c_1, c_2)$\\


%$\underline{\decom(\crs, \sk, c)}$     & $\underline{\fdecom(\crs,c)}$ \\
%Parse $c$ as $(c_0, c_1, c_2, \pi)$  & Parse $c$ as $(c_0, c_1, c_2, \pi)$ \\
%if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$  & if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$\\
%\tab Compute $y_1:= c_0^{k} \bmod N$  &   \tab Compute $ y_2:=c_0^{2^T} \bmod N$ \\
%\tab return $c_1 \cdot y_1^{-1} \bmod N$ & \tab return $c_2 \cdot y_2^{-1} \bmod N$ \\
%return $\bot$ & return $\bot$\\

\hline          
\end{tabular}
\caption{Construction of Multiplicatively Homomorphic NITC in ROM. \\ $\otimes_N$ refers to multiplication $\bmod N$}
\label{table:nitc-mh-rom}
\end{center}
\end{figure}

%Where $(\nizk.\prove, \nizk.\vrfy)$ is the Fiat-Shamir transform of the Sigma protocol for language $L_4$ defined in Cref.... Concretely, $H$ is a hash function modelled as a random oracle, then our $\nizk$ is defined as follows
%\begin{itemize}
%\item $\nizk.\prove(s:=(h_1, h_2, c_0, c_1, c_2), w:=(m, r)):$ Compute $\alpha \rand \smplsetqrn, a_0:=g^\alpha \bmod N, a_1:= (h_1\cdot h_2^{-1})^\alpha \bmod N, v:=H(s,a_0,a_1), z:= \alpha + v \cdot r$ and return $\pi:=(a_0,a_1,z)$.
%\item $\nizk.\vrfy(s:=(h_1, h_2, c_0, c_1, c_2),\pi:=(a_0,a_1,z)):$ Compute $v:=v:=H(s,a_0,a_1)$ and return 1 if and only if $g^z = a_0 \cdot c_0^v \bmod N \land (h_1\cdot h_2^{-1})^z = a_1 \cdot (c_1\cdot c_2^{-1})^v \bmod N \land z \in [\estordqrn + v\estordqrn]$.
%\end{itemize}

%\begin{figure}[h!]
%\begin{center}
%\begin{tabular}{|ll|}
%\hline
%$\underline{\pgen(\seck, T)}$ 							   & $\underline{\com(\pk, m)}$ \\
%$(p, q_, N) \leftarrow \genmod(\seck)$ & $r \rand \smplset$  \\
%$\varphi(N):= (p-1)(q-1)$   & Compute $c_0:= g^r \bmod N$ \\
%Sample random generator $g$ of $\Jn$ & For $i \in [3]: c_i:= h_i^{rN}(1+N)^m \bmod N^2$\\
%$k_1, k_2 \rand \smplset$ & $\Phi := (h_1c_0, c_1, c_2, c_3), w := (m, r)$ \\
%$t:= 2^T \bmod \varphi(N)/2$ &  $\pi \leftarrow \nizk.\prove(\Phi, w)$\\
%For $i \in [2]: h_i:= g^{k_i} \bmod N$ &  $c := (c_0, c_1, c_2, c_3, \pi)$\\
%$h_3:=g^{t} \bmod N$ &  $\pi_\com:= \bot, \pi_\dec: = r$ \\
%%$\crs \leftarrow \nizk.\setup(\seck)$ & \\
%return $\crs:= (N,T,g,h_1,h_2, h_3)$ & return $(c, \pi_\com, \pi_\dec)$\\
%%return $\crs$     & \\
%                                             &\\
%$\underline{\cvrfy(\crs, c, \pi_\com)}$     & $\underline{\dvrfy(\crs,c, m, \pi_\dec)}$ \\
%Parse $c$ as $(c_0, c_1, c_2, c_3 \pi)$  & Parse $c$ as $(c_0, c_1, c_2, c_3 \pi)$ \\
%return $\nizk.\vrfy((c_0, c_1, c_2, c_3,), \pi)$  & if $ \land_{i=1}^3 c_i = h_i^{rN}(1+N)^m  \bmod N^2 \land c_0 = g^r \bmod N$\\
% & \tab return 1 \\
%& return 0 \\
%                                             &\\
%$\underline{\fdecom(\crs,c)}$ & $\underline{\fdvrfy(\crs,c, m, \pi_\fdecom)}$ \\
%Parse $c$ as $(c_0, c_1, c_2, c_3, \pi)$ & Parse $c$ as $(c_0, c_1, c_2, c_3, \pi)$\\
%if $\nizk.\vrfy((c_0, c_1, c_2,c_3), \pi)= 1$& if $\nizk.\vrfy((c_0, c_1, c_2,c_3), \pi)= 1 \land $\\
%\tab Compute $ \pi_\fdecom:=c_0^{2^T} \bmod N$ &  $c_3 = \pi_\fdecom^N (1+N)^m \bmod N^2$\\
%\tab Compute $m:=\frac{c_3 \cdot \pi_\fdecom^{-N} (\bmod N^2) -1}{N}$ &\tab return 1\\
%\tab return $(m,\pi_\fdecom)$ & return 0\\
%return $\bot$ & \\
%
%%$\underline{\decom(\crs, \sk, c)}$     & $\underline{\fdecom(\crs,c)}$ \\
%%Parse $c$ as $(c_0, c_1, c_2, \pi)$  & Parse $c$ as $(c_0, c_1, c_2, \pi)$ \\
%%if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$  & if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$\\
%%\tab Compute $y_1:= c_0^{k} \bmod N$  &   \tab Compute $ y_2:=c_0^{2^T} \bmod N$ \\
%%\tab return $c_1 \cdot y_1^{-1} \bmod N$ & \tab return $c_2 \cdot y_2^{-1} \bmod N$ \\
%%return $\bot$ & return $\bot$\\
%
%\hline          
%\end{tabular}
%\caption{NY Construction of NITC}
%\label{table:nitc}
%\end{center}
%\end{figure}



\begin{theorem}
\label{thm:NITC-mul-ROM}
If $\Sigma = (\prv, \vrf)$ is a Sigma protocol for $L$ with quasi unique responses and $\delta$-unpredictable commitments which is sound with respect to auxiliary input $\aux=(p,q)$ and is honest verifier zero-knowledge, $H: \qrn^7 \rightarrow [2^d]$ is a hash function modelled as a random oracle,  the strong sequential squaring assumption with gap $\gap$ holds relative to $\genmod$ in $\qrn$, and the Decisional Diffie-Hellman assumption holds relative to $\genmod$ in $\qrn$, then \mathlist{(\pgen, \com, \cvrfy, \dvrfy, \fdecom)} defined in \Cref{table:nitc-mh-rom} is an IND-CCA-secure non-interactive timed commitment scheme with $\ugap$, for any $\ugap < \gap$. 
\end{theorem}

% \todo{appendix?}
\begin{proof}
Completeness is implied by the completeness of the NIZK and can be verified by inspection. 

%Our construction is based on the Naor-Yung paradigm where we combine three ElGamal-type ciphertext with shared randomness.  


%Similarly to \cite{SCN:BiaMasVen16} we define a PPT algorithm $\rerand$ in Figure~\ref{fig:rerand}, which takes two ciphertexts generated with independent randomness, both public keys, only one secret key (in our case $k$) and randomness which was used to encrypt a message using the public key $g, h_1$. 
%%We assume that modulus $N$ is implicitly known.\todo{Why not explicit?} 
%% which corresponds to the secret key which is given as the input. 
%
%\begin{figure}[tb]
%\centering
%\begin{minipage}{0.75\textwidth}
%$\underline{\rerand(c:= (g^{r}, h_1^{r}\cdot m), c':= (g^{r'}, h_2^{r'}\cdot m), N, h_1, h_2, k, r)}:$
%\vspace{-2mm}
%\begin{itemize}
%\item $c_0:= g^{r}\cdot{g^{r'}} = g^{r+r'} \bmod N$;
%\item $c_1:= (g^{r'})^k \cdot h_1^{r}\cdot m  =  h_1^{r'}\cdot h_1^{r}\cdot m = h_1^{r+r'}\cdot m \bmod N$;
%\item $c_2:=h_2^{r} \cdot h_2^{r'}\cdot m = h_2^{r+r'}\cdot m \bmod N$.
%\end{itemize}
%\end{minipage}
%\caption{\label{fig:rerand}Algorithm $\rerand$.}
%\end{figure}
%
%
%
%
%It is straightforward to see that the ciphertext returned by $\rerand$ is perfectly distributed to the ciphertext produced using a shared randomness where the pair $(c_0, c_1)$ encrypts a message $m$ and the pair $(c_0, c_2)$ encrypts message $m'$.


% We note that if we use value $2^T$ as a secret key, then in order to compute $c_2$ we have to execute $T$ repeated squarings, but since $T$ is polynomial in $\secpar$ this computations is considered to be efficient.

\newsequenceofgames{NITC-MH-ROM}
To prove security we define a sequence of games $\games_0 - \games_{8}$.  For $i \in \{0,1,\dots,8\}$ we denote by $\games_i = 1$ the event that the adversary $\adv = \{(\adv_{1,\secpar}, \adv_{2, \secpar})\}_{\secpar \in \nats}$ outputs $b'$ in the game $\games_i$ such that $b = b'$.
%In individual games we use the algorithm $\decom$ define in \Cref{fig:deco-rom-mh} to answer decommitment queries efficiently. 
\begin{figure}[h!]
\begin{center}
\begin{tabular}{|l|}
\hline
$\underline{\decom(\crs, c, \pi_\com, i, \sk)}$\\
Parse $c$ as $(c_0, c_1, c_2)$\\
if $\nizk.\vrfy((h_1, h_2, c_0, c_1, c_2), \pi_\com)= 1$\\
\tab Compute $y:= c_0^{\sk} \bmod N$\\
\tab return $c_i \cdot y^{-1} \bmod N$\\
return $\bot$\\
\hline          
\end{tabular}
\caption{Decommitment oracle}
\label{fig:deco-rom-mh}
\end{center}
\end{figure}

In the following we assume that the underlying sigma protocol produces transcripts of the form $(a,v,z)$, where any of these values can be vectors. 
\nextgame{G0}
Game $\games_\thisgame$ corresponds to the original security experiment where decommitment queries are answered using $\fdecom$.

\nextgame{DecOracle}
In game $\games_\thisgame$ decommitment queries are answered using the algorithm $\decom$ defined in \Cref{fig:deco-rom-mh} with $i:=1, \sk:=k_1$ which means that secret key $k_1$ and ciphertext $c_1$ are used, to answer decommitment queries efficiently. 

\begin{lemma}\label{nitc-rom-mh:flem}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq Q\cdot\snd^\Sigma_\advB.
\]
\end{lemma}

Notice that if $c_1$ and $c_2$ contain the same message, both oracles answer decommitment queries consistently. Let $\event$ denote the event that the adversary $\adv$ asks a decommitment query $(c:=(c_0,c_1,c_2), \pi_\com:=(a,z))$ such that its decommitment using the key $k_1$ is different from its decommitment using $\fdecom$. Since $\games_\prevgame$ and $\games_\thisgame$ are identical until $\event$ happens, we bound the probability of $\event$. Concretely, we have

\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \Pr[\event]. 
\]

We construct an adversary $\advB$ that breaks soundness with respect to auxiliary input $\aux:=(p,q)$ of the Sigma protocol.  W.l.o.g. we assume that whenever event $\event$ happens, $\adv$ previously asked the random oracle $H$ on input $(h_1,h2,c_0,c_1,c_2,a)$. The argument for this is that it is straightforward to transform any adversary that violates this condition into an adversary that makes one additional query to $H$ and wins with the same probability. Let $\adv$ makes at most $Q$ random oracle queries. 
The adversary $\advB_{\secpar}(p,q)$ proceeds as follows:
\vspace{-2mm}
\begin{enumerate}
\item Samples $k_1\rand \smplsetqrn$, computes $h_1 := g^{k_1} \bmod N,\varphi(N):=(p-1)(q-1), t:=2^{T} \bmod \ordqrn, h_2:=g^t \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2)$. 
\item Then it runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
\item Samples $i \rand [Q]$ and answers random oracle queries $(h_1^j, h_2^j, c_0^j,c_1^j,c_2^j,a^j)$ in the following way:
\begin{itemize}
\item If $i=j$ it runs the protocol with the honest verifier $\vrf$ for statement $(h_1^j, h_2^j, c_0^j,c_1^j,c_2^j)$ using as a commitment value $a^j$. It obtains challenge $v$ from $\vrf$ and it programs the oracle $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a^j):=v$ if . Answer the query with $v$.
\item Otherwise, it returns $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a^j)$ if it is set. If this is not the case samples $v_j$, sets $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a^j):=v_j$ and returns $v_j$.
\end{itemize}
\item It samples $b \rand \bits, r \rand \smplsetqrn$ and computes $c_0^*:=g^r, c_1^*:=h_1^{r}m_b, c_2^*:=h_2^{r}m_b$. It sets $(s:=\mathlist(h_1, h_2,c_0^*, c_1^*, c_2^*), w:=(m,r))$ and produces honest proof $\pi^*$.
\item Next, it runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
\item Finally, it checks whether there exists a decommitment query $(c: = \mathlist(c_0, c_1, c_2), \pi_\com=(a,z))$ such that $\deco(\crs, c, \pi_\com) \neq \dec(\crs,c,\pi_\com, 1, k_1)$. This check can be done efficiently with the knowledge of $t$. If $\event$ occurs and $\advB_\secpar$ has guessed index $i$ correctly, then value $z$ allows $\advB_\secpar$ succeed in the attack game. %Notice that this can be done efficiently with the knowledge of $t$.
\end{enumerate}

Suppose that the query $(h_1, h_2,c_0,c_1,c_2,a)$ has been asked to the random oracle as $i^*$-th query and that $i=i^*$. Then it holds
\[\snd^\Sigma_\advB = \Pr[\event \land i=i^*] = \Pr[\event]\Pr[i=i^*] = \frac{1}{Q}\Pr[\event],\]
where the first equality holds since the events are independent.
%$\advB$ simulates $\games_\thisgame$ perfectly and if the event $\event$ happens, then it outputs a valid proof for a statement which is not in the specified language $L$. Therefore we get
%\[\Pr[\event] \leq \snd^\nizk_\advB.\]

%===========================================================Soundness==================================================
%We construct an adversary $\advB$ that breaks soundness with respect to auxiliary input $\aux:=(p,q)$ of the NIZK. 
%The adversary $\advB_{\secpar}(p,q)$ proceeds as follows:
%\vspace{-2mm}
%\begin{enumerate}
%\item Samples $k_1\rand \smplsetqrn$, computes $h_1 := g^{k_1} \bmod N,\varphi(N):=(p-1)(q-1), t:=2^{T} \bmod \ordqrn, h_2:=g^t \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2)$. 
%\item Then it runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
% It samples $b \rand \bits, r \rand \smplsetqrn$ and computes $c_0^*:=g^r, c_1^*:=h_1^{r}m_b, c_2^*:=h_2^{r}m_b$. It sets $(s:=\mathlist(h_1, h_2,c_0^*, c_1^*, c_2^*), w:=(m,r))$ and runs $\pi^* \leftarrow \nizk.\prove(s,w)$.
%\item Next, it runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
%\item Finally, it checks whether there exists a decommitment query $c: = \mathlist(c_0, c_1, c_2, \pi)$ such that $\fdecom(\crs, c) \neq \dec(\crs,c,k_1,1)$. If $\event$ occurs, then this is the case, and it returns $((h_1, h_2, c_0, c_1, c_2), \pi)$. Notice that this can be done efficiently with the knowledge of $t$.
%\end{enumerate}
%
%$\advB$ simulates $\games_\thisgame$ perfectly and if the event $\event$ happens, then it outputs a valid proof for a statement which is not in the specified language $L$. Therefore we get
%\[\Pr[\event] \leq \snd^\nizk_\advB.\]
%====================================================================================================================


%\begin{lemma}\label{nitc-rom-mh:flem}
%\[
%\Pr[\games_\prevgame = 1] = \Pr[\games_\thisgame = 1].
%\]
%\end{lemma}
%
%Notice that both $\fdecom$ and $\decom$ answer decommitment queries in the exactly same way, hence the change is only syntactical. 



%Notice that if $c_1$ and $c_3$ contain the same message, both oracles answer decommitment queries consistently. Let $\event$ denote the event that the adversary $\adv$ asks a decommitment query $c$ such that its decommitment using the key $k_1$ is different from its decommitment using $\fdecom$. Since $\games_\prevgame$ and $\games_\thisgame$ are identical until $\event$ happens, we bound the probability of $\event$. Concretely, we have
%
%\[
%\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \Pr[\event]. 
%\]
%
%We construct an adversary $\advB$ that breaks soundness of the NIZK. 
%The adversary $\advB_{\secpar}$ proceeds as follows:
%\vspace{-2mm}
%\begin{enumerate}
%\item It computes $\crs \leftarrow \pgen(\seck, T)$ as defined in the construction where the value $h_3$ is computed using repeated squaring instead.
%\item Then it runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
% It samples $b \rand \bits, r \rand \smplset$ and computes $c_0^*:=g^r, c_1^*:=h_1^{r}m_b, c_2^*:=h_2^{r}m_b, c_3^*:=h_3^{r}m_b$. It sets $(s:=\mathlist(c_0^*, c_1^*, c_2^*, c_3^*), w:=(m,r))$ and runs $\pi^* \leftarrow \nizk.\prove(s,w)$.
%\item Next, it runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*, c_3^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
%\item Finally, it checks whether there exists a decommitment query $c: = \mathlist(c_0, c_1, c_2, c_3, \pi)$ such that $\fdecom(\crs, c) \neq \dec(\crs,c,1)$. If $\event$ occurs, then this is the case, and it returns $((h_1, h_2, c_0, c_1, c_2, c_3), \pi)$. %Notice that this can be done efficiently with the knowledge of $t$.
%\end{enumerate}
%
%$\advB$ simulates $\games_\thisgame$ perfectly and if the event $\event$ happens, then it outputs a valid proof for a statement which is not in the specified language $L$. Therefore we get
%\[\Pr[\event] \leq \snd^\nizk_\advB.\]

%Let $\gnr$ denote the event that the sampled $g$ in $\kgen$ is a generator of $\qrn$. Recall that $N = pq$ where $p = 2p'+1$ and $q = 2q'+1$. Because $g$ is sampled uniformly at random and $\qrn$ has $\varphi(|\qrn|) = (p'-1)(q'-1)$ generators, this event happens with overwhelming probability. Concretely, $\Pr[\gnr] = 1-\frac{1}{p'}-\frac{1}{q'}+\frac{1}{p'q'}$.
%Therefore the following holds.
%\begin{lemma}\label{tpke3:flem} 
%\begin{align*}
%\Pr[\games_\thisgame = 1] &= \Pr[\games_\thisgame = 1| \gnr]\Pr[\gnr] + \Pr[\games_\thisgame = 1| \overline{\gnr}]\Pr[\overline{\gnr}] \\
%&\leq \Pr[\games_\thisgame = 1| \gnr]\Pr[\gnr] + \Pr[\overline{\gnr}] \\
%&= \Pr[\games_\thisgame = 1| \gnr]\left( 1-\frac{1}{p'}-\frac{1}{q'}+\frac{1}{p'q'} \right) + \frac{1}{p'}+\frac{1}{q'}-\frac{1}{p'q'}.
%\end{align*}
%\end{lemma}




\nextgame{SimulProof}
Game $\games_\thisgame$ proceeds exactly as the previous game but we use the HVZK simulator $\simul$ to produce a simulated proof for the challenge commitment $ (h_1, h_2, c_0^*,c_1^*,c_2^*)$ and upon receiving simulated transcript $(a^*,v^*,z^*)$ from the simulator we try to program the random oracle in the following way: if $H\mathlist(h_1, h_2, c_0^*,c_1^*,c_2^*, a^*)=\bot$ then $H(h_1, h_2, c_0^*,c_1^*,c_2^*, a^*):=v^*$ and setting $\pi^*=(a^*,z^*)$. Now notice that, since the transcripts have the exactly same distributions, the games proceeds exactly the same until our programming of random oracle is successful. Let denote by $\event$ the event that we are not able to set correct value for $H$. $\event$ happens only in the case that adversary already asked a random oracle query at the point $H(h_1, h_2, c_0^*,c_1^*,c_2^*, a^*)$. Let $Q$ is the number of random oracle queries asked by $\adv$. Since the Sigma protocol has $\delta$-unpredictable commitments the probability of this event is by union bound  is less than $Q\delta$. Hence we obtain
\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq Q\delta.
\]
\end{lemma}


%We construct an adversary $\advB = \{\advB_\secpar\}_{\secpar \in \N}(p,q)$ against honest verifier zero-knowledge security of the Sigma protocol as follows:
%\vspace{-2mm}
%\begin{enumerate}
%\item Samples $k_1\rand \smplsetqrn$, computes $h_1 := g^{k_1} \bmod N,\varphi(N):=(p-1)(q-1), t:=2^{T} \bmod \ordqrn, h_2:=g^t \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2)$. 
%\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
%\item It answer random oracle queries $(h_1^j, h_2^j, c_0^j,c_1^j,c_2^j,a_0^j,a_1^j)$ in the following way:
%if $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a)\neq \bot$ return $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a)$ . If this is not the case samples $v_j$ uniformly at random from the challenge space, sets $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a_0^j,a_1^j):=v_j$ and returns $v_j$.
%\item Samples $b \rand \bits, r \rand \smplset$ and computes $c_0^*:=g^r, c_1^*:=h_1^{r}m_b, c_2^*:=h_2^{r}m_b$. It submits $(s:=\mathlist(h_1,h_2,c_0^*, c_1^*, c_2^*), w:=(m,r))$ to its oracle and obtains transcript  as answer.
%\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
%\item Returns the truth value of $b=b'$.
%\end{enumerate}
%If the proof $\pi^*$ is generated using $\nizk.\prove$, then $\advB$ simulates $\games_\prevgame$ perfectly. Otherwise $\pi^*$ is generated using $\simul_1$ and $\advB$ simulates $\games_\thisgame$ perfectly. This proofs the lemma.

%===============================================ZK======================================================================
%Game $\games_\thisgame$ proceeds exactly as the previous game but we use the zero-knowledge simulator $(\pi, \st) \leftarrow \simul(1, \st, (h_1, h_2, c_0^*,c_1^*,c_2^*))$ to produce a simulated proof for the challenge commitment and $\simul(2, \st, \cdot)$ to answer random oracle queries. By zero-knowledge security of underlying NIZK we directly obtain
%\begin{lemma}
%\[
%\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \zk^\nizk_\advB.
%\]
%\end{lemma}
%
%
%We construct an adversary $\advB = \{\advB_\secpar\}_{\secpar \in \N}(p,q)$ against zero-knowledge security of NIZK as follows:
%\vspace{-2mm}
%\begin{enumerate}
%\item Samples $k_1\rand \smplsetqrn$, computes $h_1 := g^{k_1} \bmod N,\varphi(N):=(p-1)(q-1), t:=2^{T} \bmod \ordqrn, h_2:=g^t \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2)$. 
%\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
%\item Samples $b \rand \bits, r \rand \smplset$ and computes $c_0^*:=g^r, c_1^*:=h_1^{r}m_b, c_2^*:=h_2^{r}m_b$. It submits $(s:=\mathlist(h_1,h_2,c_0^*, c_1^*, c_2^*), w:=(m,r))$ to its oracle and obtains proof $\pi^*$ as answer.
%\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*), \pi^*, \st)$ and answers decommitment queries using $k_1$.
%\item Returns the truth value of $b=b'$.
%\end{enumerate}
%If the proof $\pi^*$ is generated using $\nizk.\prove$, then $\advB$ simulates $\games_\prevgame$ perfectly. Otherwise $\pi^*$ is generated using $\simul_1$ and $\advB$ simulates $\games_\thisgame$ perfectly. This proofs the lemma.
%============================================================================================================================

\nextgame{RndExp}
In $\games_\thisgame$ we sample $r$ uniformly at random from $[\ordqrn]$. 
\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \frac{1}{p}+\frac{1}{q}-\frac{1}{N}.
\]
\end{lemma}
Since the only difference between the two games is in the set from which we sample $r$, to upper bound the advantage of adversary we can use \Cref{sampling-lemma} with $\ell:=4$, which directly yields required upper bound.

\nextgame{SSSA}
In $\games_\thisgame$ we sample $y_2 \rand \qrn$ and compute $c_2^*$ as $y_2 m_b$.

Let $\tilT_\sss(\secpar)$ be the polynomial whose existence is guaranteed by the SSS assumption.
Let $\poly_\advB(\secpar)$ be the fixed polynomial which bounds the time required to execute Steps 1--2 and answer decommitment queries in Step 3 of the adversary $\advB_{2, \secpar}$ defined below. Set $\undT := (\poly_\advB(\secpar))^{1 / \ugap}$.  Set $\tilT_\nitc := \max(\tilT_\sss, \undT)$.
\begin{lemma}
From any polynomial-size adversary $\adv = \{(\adv_{1,\secpar}, \adv_{2, \secpar})\}_{\secpar \in \nats}$, where depth of $\adv_{2, \secpar}$ is at most $T^{\ugap}(\secpar)$ for some $T(\cdot) \geq \undT(\cdot)$ we can construct a polynomial-size adversary $\advB = \{(\advB_{1,\secpar}, \advB_{2, \secpar})\}_{\secpar \in \nats}$ where the depth of $\advB_{2, \secpar}$ is at most $T^{\gap}(\secpar)$ with
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \advtg_\advB^\sss.
\]
\end{lemma}

The adversary $\advB_{1,\secpar}(N, T(\secpar), g):$
\vspace{-2mm}
\begin{enumerate}
\item Samples $k_1 \rand \smplsetqrn$, computes $h_1 := g^{k_1} \bmod N, h_2 := g^{2^{T(\secpar)}} \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2)$. Notice that value $h_2$ is computed by repeated squaring.
\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$. Random oracle queries are answered as before. 
\item Outputs $(N,g,k_1, h_1,h_2, m_0, m_1, \st)$
\end{enumerate}

The adversary $\advB_{2,\secpar}(x,y,(N,g,k_1, h_1,h_2, m_0, m_1, \st)):$
\vspace{-2mm}
\begin{enumerate}
\item Samples $b \rand \bits$, computes $c_0^*:=x, c_1^*:=x^{k_1} m_b, c_2^*:=y m_b$.
\item Runs $(a^*,v^*,z^*) \leftarrow \simul(h_1, h_2, c_0^*, c_1^*, c_2^*)$. If $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*) = \bot$ sets $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*) = v^*$. Sets $\pi^* = (a^*,z^*)$.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*), \pi^*, \st)$ and answers decommitment queries using $k_1$. Random oracle queries are answered as before. 
\item Returns the truth value of $b=b'$.
\end{enumerate}
Since $g$ is a generator of $\qrn$ and $x$ is sampled uniformly at random from $\qrn$ there exists some $r \in [\varphi(N)/2]$ such that $x = g^{r}$. Therefore when $y = x^{2^T} = (g^{2^T})^{r} \bmod N$, then $\advB$ simulates $\games_\prevgame$ perfectly. Otherwise $y$ is random value and $\advB$ simulates $\games_\thisgame$ perfectly. We remark that at this point $c_2^*$ does not reveal any information about $m_b$.

Now we analyse the running time of the constructed adversary. Adversary $\advB_1$ computes $h_3$ by $T(\secpar)$ consecutive squarings and because $T(\secpar)$ is polynomial in $\secpar$, $\advB_1$ is efficient. Moreover, $\advB_2$ fulfils the depth constraint:
\[ \dep(\advB_{2,\secpar}) = \poly_\advB(\secpar) + \dep(\adv_{2,\secpar}) \leq \undT^{\ugap}(\secpar) + T^{\ugap}(\secpar) \leq 2 T^{\ugap}(\secpar) = o(T^{\gap}(\secpar)). \] 

Also $T(\cdot) \geq \tilT_\nitc(\cdot) \geq \tilT_\sss(\cdot)$ as required.  


\nextgame{QUR}
Let $(c^*, \pi^*_com=(a^*,z^*))$ is the challenge commitment. In $\games_\thisgame$ we abort experiment if adversary asks any decommitment query $(c,\pi_\com=(a,z))$ such that $c=c^*, a = a^*$ and $z \neq z^*$. We denote this event by $\event$.
\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \qur^\sigma_\advB.
\]
\end{lemma}


Since $\games_\prevgame$ and $\games_\thisgame$ are identical until $\event$ does not happen, by the standard argument it is sufficient to upper bound the probability of happening $\event$. Concretely,  

\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \Pr[\event]. 
\]

We construct an adversary $\advB$ which breaks quasi unique responses property of the Sigma protocol. 
The adversary $\advB_{\secpar}$ proceeds as follows:
\vspace{-2mm}
\begin{enumerate}
\item Samples $k_1\rand \smplsetqrn$, computes $h_1 := g^{k_1} \bmod N, h_2:=g^{2^T} \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2)$. Notice that $h_2$ is computed by repeated squaring. 
\item Then it runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$. Random oracle queries are answered as before. 
\item Samples $b \rand \bits$, computes $c_0^*:=x, c_1^*:=x^{k_1} m_b, c_2^*:=y m_b$.
\item Runs $(a^*,v^*,z^*) \leftarrow \simul(h_1, h_2, c_0^*, c_1^*, c_2^*)$. If $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*) = \bot$ sets $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*) = v^*$. Sets $\pi^* = (a^*,z^*)$.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*), \pi^*, \st)$ and answers decommitment queries using $k_1$. Random oracle queries are answered as before. 
\item Returns the truth value of $b=b'$.
\item Finally, it checks whether there is a decommitment query $(c,\pi=(a,z))$ such that $c= c^*, a = a^*$ and $z \neq z^*$. If $\event$ occurs, then this is the case, and it returns $((h_1, h_2, c_0^*, c_1^*, c_2^*),a^*,v^*,z^*,z)$ where $v^* = H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*)$.
\end{enumerate}

Notice, that if $\event$ happens that $\advB_\secpar$ indeed provides two transcripts which has different responses which yields
\[\Pr[\event] \leq \qur^\Sigma_\advB.\]

\nextgame{Snd2}
In game $\games_\thisgame$ decommitment queries are answered using the algorithm $\decom$ defined in \Cref{fig:deco-rom-mh} with $i:=2, \sk:=t$ which means that secret key $t$ and ciphertext $c_2$ are used, to answer decommitment queries efficiently. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq Q\cdot\snd^\Sigma_\advB.
\]
\end{lemma}

Let $\event$ denote the event that adversary $\adv$ asks a decommitment query $(c, \pi_\com=(a_0,a_1,z))$ such that its decommitment using the key $k_1$ is different from its decommitment using the key $t$. Since $\games_\prevgame$ and $\games_\thisgame$ are identical until $\event$ does not happen, by the standard argument it is sufficient to upper bound the probability of happening $\event$. Concretely,  

\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \Pr[\event]. 
\]


We construct an adversary $\advB$ that breaks soundness with respect to auxiliary input $\aux:=(p,q)$ of the Sigma protocol. W.l.o.g. we assume that whenever event $\event$ happens, $\adv$ previously asked the random oracle $H$ on input $(h_1,h_2,c_0,c_1,c_2,a)$. The argument for this is that it is straightforward to transform any adversary that violates this condition into an adversary that makes one additional query to $H$ and wins with the same probability. Let $\adv$ makes at most $Q$ random oracle queries. 
The adversary $\advB_{\secpar}(p,q)$ proceeds as follows:
\vspace{-2mm}
\begin{enumerate}
\item Samples $k_1\rand \smplsetqrn$, computes $h_1 := g^{k_1} \bmod N,\varphi(N):=(p-1)(q-1), t:=2^{T} \bmod \ordqrn, h_2:=g^t \bmod N$ and sets $\crs:=(N, T(\secpar), g, h_1, h_2)$. 
\item Then it runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $k_1$.
\item Samples $i \rand [Q]$ and answers random oracle queries $(h_1^j, h_2^j, c_0^j,c_1^j,c_2^j,a^j,)$ in the following way:
\begin{itemize}
\item If $i=j$ it runs the protocol with the honest verifier $\vrf$ for statement $(h_1^j, h_2^j, c_0^j,c_1^j,c_2^j)$ using as a commitment value $a^j$. It obtains challenge $v$ from $\vrf$ and it programs the oracle $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a^j):=v$. Answer the query with $v$.
\item Otherwise, if $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a^j) \neq \bot$ returns $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a^j)$. Else it samples $v_j$, sets $H(h_1^j, h_2^j,c_0^j,c_1^j,c_2^j,a^j):=v_j$ and returns $v_j$.
\end{itemize}
\item Samples $b \rand \bits, x, y_2 \rand \qrn$ and computes $(c_0^*, c_1^*, c_2^*):=(x, x^{k_1} m_b,\allowbreak y_2 m_b)$. 
\item Runs $(a^*,v^*,z^*) \leftarrow \simul(h_1, h_2, c_0^*, c_1^*, c_2^*)$. If $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*) = \bot$ sets $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*) = v^*$. Sets $\pi^* = (a^*,z^*)$.
%Run the HVZK simulator on $(h_1, h_2, c_0^*, c_1^*, c_2^*)$ to to obtain an accepting transcript $(a,v,z)$ and in case that $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a)$ is already defined with value different to $v$ it aborts the experiment, otherwise it programs the oracle $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a):=v$ and outputs $(a,z)$.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*), \pi^*, \st)$ and answers decommitment queries using $k_1$ and random oracle queries in the same way as before.
\item Finally, it checks whether there exists a decommitment query $(c, \pi_\com=(a,z))$ such that $\dec(\crs, c, \pi_\com, 1, k_1) \neq \dec(\crs,c, \pi_\com, 2 ,t)$. If $\event$ occurs, then this is the case and it returns $z$ as a response to the challenge $v$. 
\end{enumerate}

Suppose that the query $(h_1, h_2,c_0,c_1,c_2,a)$ has been asked to the random oracle as $i^*$-th query and that $i=i^*$. Then $\advB_\secpar$ guesses a correct index for which $\adv$ asks decommitment query for a statement which is not in the specified language $L$. Therefore we get
\[\snd^\Sigma_\advB = \Pr[\event \land i=i^*] = \Pr[\event]\Pr[i=i^*] = \frac{1}{Q}\Pr[\event],\]
where the first equality holds since the events are independent.


\nextgame{RndExp4}
In $\games_\thisgame$ we sample $k_1$ uniformly at random from $[\ordqrn]$.

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \frac{1}{p}+\frac{1}{q}-\frac{1}{N}.
\]
\end{lemma}

This lemma directly follows from \Cref{sampling-lemma} with $\ell:=4$.

\nextgame{DDH1}
In $\games_\thisgame$ we sample $y_1 \rand \qrn$ and compute $c_1^*$ as  $y_1 m_b$. 

\begin{lemma}
\[
\left|\Pr[\games_\prevgame = 1] - \Pr[\games_\thisgame = 1]\right| \leq \advtg_\advB^\ddh.
\]
\end{lemma}
We construct an adversary $\advB = \{\advB_\secpar\}_{\secpar \in \N}$ against DDH in the group $\qrn$. %Given \Cref{thm:ddh} this implies an adversary against DDH in large prime-order subgroups of $\Zn^*$.

$\advB_{\secpar}(N,p,q,g,g^\alpha, g^\beta, g^\gamma):$
\vspace{-2mm}
\begin{enumerate}
\item Computes $\varphi(N):=(p-1)(q-1), t:=2^{T} \bmod \varphi(N)/4, h_2:=g^t \bmod N$ and sets $\crs:=(N, T, g, h_1: = g^\alpha, h_2)$.
\item Runs $(m_0, m_1, \st) \leftarrow \adv_{1, \secpar}(\crs)$ and answers decommitment queries using $t$. Random oracle queries are answered as before.
\item Samples $b \rand \bits$ and computes $(c_0^*, c_1^*, c_2^*):=(g^\beta, g^\gamma \cdot m_b, (g^\beta)^t \cdot m_b).$ 
\item Runs $(a^*,v^*,z^*) \leftarrow \simul(h_1, h_2, c_0^*, c_1^*, c_2^*)$. If $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*) = \bot$ sets $H(h_1, h_2, c_0^*, c_1^*, c_2^*,a^*) = v^*$. Sets $\pi^* = (a^*,z^*)$.
\item Runs $b' \leftarrow \adv_{2, \secpar}((c_0^*, c_1^*, c_2^*), \pi^*, \st)$ and answers decommitment queries using $t$. Random oracle queries are answered as before.
\item Returns the truth value of $b=b'$. We remark that at this point $c_1^*$ does not reveal any information about $m_b$.
\end{enumerate}
If $\gamma = \alpha\beta$ then $\advB$ simulates $\games_\prevgame$ perfectly. Otherwise $g^\gamma$ is uniform random element in $\qrn$ and $\advB$ simulates $\games_\thisgame$ perfectly. This proofs the lemma. We remark that at this point $c_1^*$ does not reveal any information about $m_b$.


\begin{lemma}\label{nitc-rom-mh:llem}
\[
\Pr[\games_\thisgame = 1] = \half.
\]
\end{lemma}

Clearly, $c_0^*$ is uniform random element in $\qrn$ and hence it does not contain any information about the challenge message. Since $y_1, y_2$ are sampled uniformly at random from $\qrn$ the ciphertexts $c_1^*, c_2^*$ are also uniform random elements in $\qrn$ and hence do not contain any information about the challenge message $m_b$. Therefore, an adversary can not do better than guessing.

By combining Lemmas \ref{nitc-rom-mh:flem} - \ref{nitc-rom-mh:llem} we obtain the following:
\begin{align*}
&\advtg^{\nitc}_{\adv} = \left| \Pr[\games_0 = 1] - \half \right| \leq \sum_{i=0}^7 \left|\Pr[\games_i = 1] - \Pr[\games_{i+1} = 1] \right| + \left|\Pr[\games_{8}- \half\right| \\
 &\leq 2Q \cdot \snd^\Sigma_\advB + Q\delta + \advtg^{\sss}_{\advB} + \qur^\Sigma_\advB + \advtg^{\ddh}_{\advB} + 2 \left( \frac{1}{p}+\frac{1}{q}-\frac{1}{N} \right),
\end{align*}
which concludes the proof.
\end{proof}
% \todo{appendix end}

\begin{theorem}
$(\pgen, \com, \cvrfy, \dvrfy, \fdecom)$ defined in \Cref{table:nitc-mh-rom} is a BND-CCA-secure non-interactive timed commitment scheme. 
\end{theorem}

\begin{proof}
This can be proven in the same way as \Cref{bnd-cca-mh}.
\end{proof}

It is straightforward to verify that considering $\eval$ algorithm, our construction yields multiplicatively homomorphic NITC. 
\begin{theorem}\label{hom-mh-rom}
The NITC \mathlist{(\pgen, \com, \cvrfy, \dvrfy, \fdecom, \fdvrfy, \eval)} defined in \Cref{table:nitc-mh-rom} is a multiplicatively homomorphic non-interactive timed commitment scheme.
\end{theorem}


\begin{remark}[Public Verifiability]
The construction can be made publicly verifiable in the same way as suggested in \Cref{rem:pv}. 
 \end{remark}

%\begin{figure}[h!]
%\begin{center}
%\begin{tabular}{|ll|}
%\hline
%$\underline{\kgen(\seck, T)}$ 							   & $\underline{\decf(\sk, c)}$\\
%$(p, q_, N) \leftarrow \genmod(\seck)$ &  Parse $c$ as $(c_0, c_1, c_2, \pi)$\\
%$\varphi(N):= (p-1)(q-1)$   & if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$ \\
%$g\rand \qrn$ & \tab Compute $y_1:= c_0^{k} \bmod N$\\
%$k \rand \varphi(N)/4$ & \tab return $c_1 \cdot H(y_1)^{-1} \bmod N$ \\
%$t:= 2^T \bmod \varphi(N)/4$ & return $\bot$\\
%$h_1:= g^k \bmod N$ & \\
%$h_2:=g^{t} \bmod N$ & \\
%%$\crs \leftarrow \nizk.\setup(\seck)$ & \\
%$\pk:= (N,T,g,h_1,h_2), \sk:= (N, k)$ & \\
%return $(\pk, \sk)$       & \\
%                                             &\\
%$\underline{\enc(\pk, m)}$           & $\underline{\decs(\pk,c)}$ \\
%$r \rand [\floor{N/4}]$     & Parse $c$ as $(c_0, c_1, c_2, \pi)$ \\
%Compute $c_0:= g^r \bmod N$ & if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$\\
%For $i \in [2]: y_i:= h_i^r \bmod N$   &   \tab Compute $ y_2:=c_0^{2^T} \bmod N$ \\
%For $i \in [2]: c_i:= H(y_i) \cdot m \bmod N$ & \tab return $c_2 \cdot H(y_2)^{-1} \bmod N$ \\
%$\Phi := (c_0, c_1, c_2), w := (m, r)$& return $\bot$\\
%$\pi \leftarrow \nizk.\prove(\Phi, w)$  &  \\
%return $c \leftarrow (c_0, c_1, c_2, \pi)$ &  \\
%
%\hline          
%\end{tabular}
%\caption{NY Construction of TPKE from SSSA}
%\label{table:tpke-elgamal}
%\end{center}
%\end{figure}

 

%\begin{figure}[h!]
%\begin{center}
%\begin{tabular}{|ll|}
%\hline
%$\underline{\kgen(\seck, T)}$ 							   & $\underline{\decf(\sk, c)}$\\
%$(p, q_, N) \leftarrow \genmod(\seck)$ &  Parse $c$ as $(c_0, c_1, c_2, \pi)$\\
%$\varphi(N):= (p-1)(q-1)$   & if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$ \\
%$g\rand \qrn$ & \tab Compute $y_1:= c_0^{k} \bmod N$\\
%$k \rand \varphi(N)/4$ & \tab return $c_1 \cdot H(y_1)^{-1} \bmod N$ \\
%$t:= 2^T \bmod \varphi(N)/4$ & return $\bot$\\
%$h_1:= g^k \bmod N$ & \\
%$h_2:=g^{t} \bmod N$ & \\
%%$\crs \leftarrow \nizk.\setup(\seck)$ & \\
%$\pk:= (N,T,g,h_1,h_2), \sk:= (N, k)$ & \\
%return $(\pk, \sk)$       & \\
%                                             &\\
%$\underline{\enc(\pk, m)}$           & $\underline{\decs(\pk,c)}$ \\
%$r \rand [\floor{N/4}]$     & Parse $c$ as $(c_0, c_1, c_2, \pi)$ \\
%Compute $c_0:= g^r \bmod N$ & if $\nizk.\vrfy((c_0, c_1, c_2), \pi)= 1$\\
%For $i \in [2]: y_i:= h_i^r \bmod N$   &   \tab Compute $ y_2:=c_0^{2^T} \bmod N$ \\
%For $i \in [2]: c_i:= H(y_i) \cdot m \bmod N$ & \tab return $c_2 \cdot H(y_2)^{-1} \bmod N$ \\
%$\Phi := (c_0, c_1, c_2), w := (m, r)$& return $\bot$\\
%$\pi \leftarrow \nizk.\prove(\Phi, w)$  &  \\
%return $c \leftarrow (c_0, c_1, c_2, \pi)$ &  \\
%
%\hline          
%\end{tabular}
%\caption{NY Construction of TPKE from SSSA}
%\label{table:tpke-elgamal}
%\end{center}
%\end{figure}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
